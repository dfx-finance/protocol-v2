

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "../src/interfaces/IAssimilator.sol";
import "../src/interfaces/IOracle.sol";
import "../src/interfaces/IERC20Detailed.sol";
import "../src/AssimilatorFactory.sol";
import "../src/CurveFactoryV2.sol";
import "../src/Curve.sol";
import "../src/Config.sol";
import "../src/Structs.sol";
import "../src/Zap.sol";
import "../src/lib/ABDKMath64x64.sol";

import "./lib/MockUser.sol";
import "./lib/CheatCodes.sol";
import "./lib/Address.sol";
import "./lib/CurveParams.sol";
import "./lib/MockChainlinkOracle.sol";
import "./lib/MockOracleFactory.sol";
import "./lib/MockToken.sol";

import "./utils/Utils.sol";

contract MultipleQuotesTest is Test {
    using SafeMath for uint256;
    using SafeERC20 for IERC20Detailed;
    CheatCodes cheats = CheatCodes(HEVM_ADDRESS);
    Utils utils;

    // account order is lp provider, trader, treasury
    MockUser[] public accounts;

    Curve[] public curves;

    // tokens
    IERC20Detailed euroc;
    IERC20Detailed cadc;
    IERC20Detailed usdc;
    IERC20Detailed usdt;
    IERC20Detailed dai;

    // oracles
    IOracle eurocOracle;
    IOracle cadcOracle;
    IOracle usdcOracle;
    IOracle usdtOracle;
    IOracle daiOracle;

    // decimals
    mapping (address => uint256) decimals;

    // curves
    Curve public eurocUsdtCurve;

    Config config;
    CurveFactoryV2 curveFactory;
    AssimilatorFactory assimFactory;

    function setUp() public {

        utils = new Utils();
        // create temp accounts
        for(uint256 i = 0; i < 4; ++i){
            accounts.push(new MockUser());
        }
        // init tokens
        euroc = IERC20Detailed(Mainnet.EUROC);
        cadc = IERC20Detailed(Mainnet.CADC);
        usdc = IERC20Detailed(Mainnet.USDC);
        usdt = IERC20Detailed(Mainnet.USDT);
        dai = IERC20Detailed(Mainnet.DAI);

        // deploy mock oracle factory for deployed token (named gold)
        eurocOracle = IOracle(Mainnet.CHAINLINK_EUR_USD);
        cadcOracle = IOracle(Mainnet.CHAINLINK_CAD_USD);
        usdcOracle = IOracle(Mainnet.CHAINLINK_USDC_USD);
        usdtOracle = IOracle(Mainnet.CHAINLINK_USDT_USD);
        daiOracle = IOracle(Mainnet.CHAINLINK_DAI_USD);

        config = new Config(50000,address(accounts[2]));
        // now add quotes
        config.addNewQuoteCurrency(address(usdt),usdt.decimals(),address(usdtOracle), usdtOracle.decimals());
        // deploy new assimilator factory & curveFactory v2
        assimFactory = new AssimilatorFactory();
        curveFactory = new CurveFactoryV2(
             address(assimFactory),
             address(config)
        );
        assimFactory.setCurveFactory(address(curveFactory));
        // now deploy curves
        eurocUsdtCurve = createCurve("euroc-usdt",address(euroc),address(usdt),address(eurocOracle),address(usdtOracle));
    }

    function createCurve(string memory name, address base, address quote,address baseOracle, address quoteOracle) public returns (Curve) {
        cheats.startPrank(address(accounts[2]));
        CurveInfo memory curveInfo = CurveInfo(
            string(abi.encode("dfx-curve-",name)),
            string(abi.encode("lp-",name)),
            base,
            quote,
            DefaultCurve.BASE_WEIGHT,
            DefaultCurve.QUOTE_WEIGHT,
            IOracle(baseOracle),
            IOracle(quoteOracle),
            DefaultCurve.ALPHA,
            DefaultCurve.BETA,
            DefaultCurve.MAX,
            DefaultCurve.EPSILON,
            DefaultCurve.LAMBDA
        );
        Curve _curve = curveFactory.newCurve(curveInfo);
        cheats.stopPrank();
        // now mint base token, update decimals map
        uint256 mintAmt = 300_000_000_000;
        uint256 baseDecimals = utils.tenToPowerOf(IERC20Detailed(base).decimals());
        decimals[base] = baseDecimals;
        deal(base,address(accounts[0]), mintAmt.mul(baseDecimals));
        // now mint quote token, update decimals map
        uint256 quoteDecimals = utils.tenToPowerOf(IERC20Detailed(quote).decimals());
        decimals[quote] = quoteDecimals;
        deal(quote,address(accounts[0]), mintAmt.mul(quoteDecimals));
        console.logString("quote minted, minted amt is ");
        console.log(IERC20Detailed(quote).balanceOf(address(accounts[0])));
        // now approve the deployed curve
        cheats.startPrank(address(accounts[0]));
        console.logString("1");
        IERC20Detailed(base).approve(address(_curve), 0);
        IERC20Detailed(base).approve(address(_curve), type(uint).max);
        console.logString("2");
        console.logString("quote address is ");
        console.log(quote);
        // IERC20Detailed(quote).approve(address(_curve), 0);
        // IERC20Detailed(quote).approve(address(_curve), type(uint).max);
        console.log("allowance");
        console.log(IERC20Detailed(quote).allowance(address(accounts[0]),address(_curve)));
        IERC20Detailed(quote).safeApprove(address(_curve), type(uint256).max);
        console.logString("3");
        cheats.stopPrank();
        console.logString("curve got approved");
        console.logString("curve created");
        return _curve;
    }
    /**
    deploy gold,usdc tokens, their price oracles, assimilators & test swap
    check if v2 factory & it's deployed curve works properly based on both token's price
    assuming both tokens are foreign stable coins
    gold usdc ratio is 1 : 20
     */
    // function testDeployTokenAndSwap(uint256 amt) public {
    //     cheats.assume(amt > 100);
    //     cheats.assume(amt < 10000000);

    //     // mint gold to trader
    //     tokens[0].mint(address(accounts[1]), amt * decimals[0]);

    //     uint256 noDecGoldBal = tokens[0].balanceOf(address(accounts[1]));
    //     noDecGoldBal = noDecGoldBal.div(decimals[0]);

    //     cheats.startPrank(address(accounts[1]));
    //     tokens[0].approve(address(curves[0]), type(uint).max);
    //     tokens[3].approve(address(curves[0]), type(uint).max);
    //     cheats.stopPrank();

    //     // first deposit
    //     cheats.startPrank(address(accounts[0]));
    //     curves[0].deposit(2000000000 * decimals[0],0,0,type(uint256).max, type(uint256).max, block.timestamp + 60);
    //     cheats.stopPrank();

    //     cheats.startPrank(address(accounts[1]));
    //     uint256 originalGoldBal = tokens[0].balanceOf(address(accounts[1]));
    //     // now swap gold to usdc
    //     curves[0].originSwap(
    //         address(tokens[0]),
    //         address(tokens[3]), 
    //         originalGoldBal,
    //         0,
    //         block.timestamp + 60
    //     );
    //     cheats.stopPrank();

    //     uint256 noDecUsdcBal = tokens[3].balanceOf(address(accounts[1]));
    //     noDecUsdcBal = noDecUsdcBal.div(decimals[3]);
    //     // burn usdc from treasury
    //     uint256 traderUsdcBal = tokens[3].balanceOf(address(accounts[1]));
    //     cheats.startPrank((address(accounts[1])));
    //     tokens[3].transfer(address(accounts[3]), traderUsdcBal);
    //     cheats.stopPrank();
    //     // price ratio is 1:20, balance ration also needs to be approx 1:20
    //     assertApproxEqAbs(noDecUsdcBal, noDecGoldBal * 20, noDecUsdcBal.div(100));
    // }
    // // test swap of forex stable coin(euroc, cadc) usdc
    // function testForeignStableCoinSwap(uint256 amt) public {
    //     cheats.assume(amt > 1000);
    //     cheats.assume(amt < 10000000);
    //     for(uint256 i = 0; i < 2; ++i){
    //         // mint token to trader
    //         deal(address(tokens[i+1]), address(accounts[1]), amt * decimals[i+1]);

    //         uint256 noDecForexBal = tokens[i+1].balanceOf(address(accounts[1]));
    //         noDecForexBal = noDecForexBal.div(decimals[i+1]);

    //         cheats.startPrank(address(accounts[1]));
    //         tokens[i+1].approve(address(curves[i+1]), type(uint).max);
    //         tokens[3].approve(address(curves[i+1]), type(uint).max);
    //         cheats.stopPrank();

    //         // first deposit
    //         cheats.startPrank(address(accounts[0]));
    //         curves[i+1].deposit(1000000000 * 1e18,0,0,type(uint256).max, type(uint256).max, block.timestamp + 60);
    //         cheats.stopPrank();

    //         cheats.startPrank(address(accounts[1]));
    //         uint256 originalForexBal = tokens[i+1].balanceOf(address(accounts[1]));
    //         // now swap forex stable coin to usdc
    //         curves[i+1].originSwap(
    //             address(tokens[i+1]),
    //             address(tokens[3]), 
    //             originalForexBal,
    //             0,
    //             block.timestamp + 60
    //         );
    //         cheats.stopPrank();

    //         uint256 noDecUsdcBal = tokens[3].balanceOf(address(accounts[1]));
    //         noDecUsdcBal = noDecUsdcBal.div(decimals[3]);

    //         (, int256 _price, , , ) = oracles[i+1].latestRoundData();
    //         uint256 price = uint256(_price);
    //         uint256 oracleDecimals = oracles[i+1].decimals();

    //         // burn usdc from treasury
    //         uint256 traderUsdcBal = tokens[3].balanceOf(address(accounts[1]));
    //         cheats.startPrank((address(accounts[1])));
    //         tokens[3].transfer(address(accounts[3]), traderUsdcBal);
    //         cheats.stopPrank();
    //         assertApproxEqAbs(noDecUsdcBal, noDecForexBal * price / (10 ** oracleDecimals), noDecUsdcBal.div(100));
    //     }
    // }

    // test euroc-usdt curve, usdt is a quote
    function testEurocUsdtCurve() public {
        uint256 amt = 1000000;
        // mint tokens to trader
        deal(address(euroc),address(accounts[1]), amt * decimals[address(euroc)]);
        cheats.startPrank(address(accounts[1]));
        euroc.approve(address(eurocUsdtCurve),type(uint256).max);
        usdt.safeApprove(address(eurocUsdtCurve), type(uint256).max);
        cheats.stopPrank();
        // deposit from lp
        cheats.startPrank(address(accounts[0]));
        eurocUsdtCurve.deposit(1000000000 * 1e18,0,0,type(uint256).max, type(uint256).max, block.timestamp + 60);
        cheats.stopPrank();
        // now trade
        cheats.startPrank(address(accounts[1]));
        uint256 e_bal_0 = euroc.balanceOf(address(accounts[1]));
        uint256 u_bal_0 = usdt.balanceOf(address(accounts[1]));
        eurocUsdtCurve.originSwap(
            address(euroc),
            address(usdt),
            e_bal_0,
            0,
            block.timestamp + 60
        );
        uint256 e_bal_1 = euroc.balanceOf(address(accounts[1]));
        uint256 u_bal_1 = usdt.balanceOf(address(accounts[1]));
        cheats.stopPrank();
        console.logString("before swap, euroc & usdt");
        console.log(e_bal_0);
        console.log(u_bal_0);
        console.logString("after swap, euroc & usdt");
        console.log(e_bal_1);
        console.log(u_bal_1);
        console.logString("swap diff, euroc & usdt");
        console.log(e_bal_0 - e_bal_1);
        console.log(u_bal_1 - u_bal_0);
    }

    // /*
    // * user swaps gold to usdc then does reverse swap into gold from usdc
    // swap amount is relatively huge compare to the pool balance
    // after 2 rounds of swap, user gets almost same amount of gold to the original gold balance
    //  */
    // function testSwapDifference (uint256 percentage) public {
    //     cheats.assume(percentage > 0);
    //     cheats.assume(percentage < 30);
    //     for(uint256 i = 0; i < 3; ++i){
    //         // first deposit from the depositor
    //         cheats.startPrank(address(accounts[0]));
    //         curves[i].deposit(10000000 * decimals[i],0,0,type(uint256).max, type(uint256).max, block.timestamp + 60);
    //         cheats.stopPrank();
    //         uint256 poolForexBal = tokens[i].balanceOf(address(curves[i]));
    //         // mint gold to trader
    //         if(i == 0)
    //             tokens[i].mint(address(accounts[1]), poolForexBal.div(100).mul(percentage));
    //         else
    //             deal(address(tokens[i]),address(accounts[1]), poolForexBal.div(100).mul(percentage));
    //         cheats.startPrank(address(accounts[1]));
    //         tokens[i].approve(address(curves[i]), type(uint).max);
    //         tokens[3].approve(address(curves[i]), type(uint).max);
    //         uint256 originalForexBal = tokens[i].balanceOf(address(accounts[1]));
    //         // first swap gold into usdc
    //         curves[i].originSwap(
    //             address(tokens[i]),
    //             address(tokens[3]),
    //             originalForexBal,
    //             0,
    //             block.timestamp + 60);
    //         // now swaps back usdc into gold
    //         curves[i].originSwap(
    //             address(tokens[3]),
    //             address(tokens[i]),
    //             tokens[3].balanceOf(address(accounts[1])),
    //             0,
    //             block.timestamp + 60
    //         );
    //         uint256 currentGoldBal = tokens[i].balanceOf(address(accounts[1]));
    //         assertApproxEqAbs(
    //             originalForexBal,
    //             currentGoldBal,
    //             originalForexBal.div(100)
    //         );
    //         cheats.stopPrank();
    //     }
    // }
}